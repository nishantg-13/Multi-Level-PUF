# -*- coding: utf-8 -*-
"""submit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KAR7uZH_CdF65xepmJ12HRmVcY9gS-7P
"""

import numpy as np
import sklearn
from scipy.linalg import khatri_rao
from sklearn.svm import LinearSVC
from sklearn.linear_model import SGDClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import LinearSVC
from sklearn.model_selection import KFold
from sklearn.metrics import accuracy_score

# You are allowed to import any submodules of sklearn that learn linear models e.g. sklearn.svm etc
# You are not allowed to use other libraries such as keras, tensorflow etc
# You are not allowed to use any scipy routine other than khatri_rao

# SUBMIT YOUR CODE AS A SINGLE PYTHON (.PY) FILE INSIDE A ZIP ARCHIVE
# THE NAME OF THE PYTHON FILE MUST BE submit.py

# DO NOT CHANGE THE NAME OF THE METHODS my_fit, my_map, my_decode etc BELOW
# THESE WILL BE INVOKED BY THE EVALUATION SCRIPT. CHANGING THESE NAMES WILL CAUSE EVALUATION FAILURE

# You may define any new functions, variables, classes here
# For example, functions to calculate next coordinate or step length


################################
# Non Editable Region Starting #
################################
def my_fit( X_train, y_train ):
################################
#  Non Editable Region Ending  #
################################

	# Use this method to train your models using training CRPs
	# X_train has 8 columns containing the challenge bits
	# y_train contains the values for responses

	# THE RETURNED MODEL SHOULD BE ONE VECTOR AND ONE BIAS TERM
	# If you do not wish to use a bias term, set it to 0

  model = SGDClassifier(loss='hinge', max_iter=10000, tol=1e-3, random_state=42)
  # model = LogisticRegression(C=1,  tol=1e-3, penalty='l2', max_iter=1000,solver = 'liblinear')
  # model = LinearSVC(C=1, tol=1e-3, penalty='l2', max_iter=10000, loss='hinge', dual=True)
  feat = my_map(X_train)
  model.fit(feat, y_train)
  w = model.coef_
  b = model.intercept_

  return w, b


################################
# Non Editable Region Starting #
################################
def my_map( X ):
################################
#  Non Editable Region Ending  #
################################

	  # Use this method to create features.
	  # It is likely that my_fit will internally call my_map to create features for train points
    X = np.asarray(X)

    D = 1 - 2 * X

    suffix = np.flip(np.cumprod(np.flip(D, axis=1), axis=1), axis=1)[:, 1:]

    phi = np.concatenate([D, suffix], axis=1)
    i, j = np.triu_indices(phi.shape[1], k=1)
    final_features = phi[:, i] * phi[:, j]


    return final_features


################################
# Non Editable Region Starting #
################################
def my_decode( w ):
################################
#  Non Editable Region Ending  #
################################

  	# Use this method to invert a PUF linear model to get back delays
   	# w is a single 65-dim vector (last dimension being the bias term)
	  # The output should be four 64-dimensional vectors
    w = np.asarray(w, dtype=np.float64).flatten()

    bias = w[64]

    p = np.empty(64, dtype=np.float64)
    p[0] = 2.0 * w[0]
    for i in range(1, 63):
        p[i] = 2.0 * w[i] - p[i - 1]

    p[63] = w[63] + bias - (p[62] * 0.5)

    r = np.zeros(64, dtype=np.float64)
    r[63] = p[63] - 2.0 * bias
    q = np.zeros(64, dtype=np.float64)
    s = np.zeros(64, dtype=np.float64)

    all_delays = np.concatenate((p, q, r, s))
    min_delay = np.min(all_delays)
    if min_delay < 0.0:
        shift = -min_delay
        p += shift
        q += shift
        r += shift
        s += shift

    return p, q, r, s